diff -N wgrib2/bifourier.c ../../wgrib2_mod/grib2/wgrib2/bifourier.c
0a1,926
> #include <math.h>
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> 
> #include "wgrib2.h"
> #include "bifourier.h"
> 
> #define MAX(x,y) ((x) > (y) ? (x) : (y))
> #define MIN(x,y) ((x) < (y) ? (x) : (y))
> 
> 
> #define BIT_MASK(x) \
>         (((x) >= sizeof(unsigned long) * 8) ? \
>                 (unsigned long) -1UL : (1UL << (x)) - 1)
> 
> static int max_nbits = sizeof(unsigned long)*8;
> 
> static unsigned long dmasks[] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, };
> 
> static int grib_encode_unsigned_long(unsigned char* p, unsigned long val ,long *bitp, long nbits)
> {
>     long len = nbits;
>     int s = *bitp % 8;
>     int n = 8 - s;
>     unsigned char tmp = 0; 
> 
>     if (nbits > max_nbits) {
>         int bits = nbits;
>         int mod = bits % max_nbits;
>         long zero = 0;
> 
>         if (mod != 0) {
>             int e = grib_encode_unsigned_long(p, zero, bitp, mod);
>             bits -= mod;
>         }
> 
>         while (bits > max_nbits) {
>             int e = grib_encode_unsigned_long(p, zero, bitp, max_nbits);
>             bits -= max_nbits;
>         }
> 
>         return grib_encode_unsigned_long(p, val, bitp, bits);
>     }
> 
>     if (s)
>         p += (*bitp >> 3); 
>     else
>         p += (*bitp >> 3); 
> 
>     if (s) {
>         len -= n;
>         if (len < 0) {
>             tmp = ((val << -len) | ((*p) & dmasks[n]));
>         } else {
>             tmp = ((val >> len) | ((*p) & dmasks[n]));
>         }
>         *p = tmp;
>         (*p)++;
>     }
> 
>     while (len >= 8) {
>         len -= 8;
>         *p++ = (val >> len);
>     }
> 
>     if (len)
>         *p = (val << (8 - len));
> 
>     *bitp += nbits;
>     return 0;
> }
> 
> 
> static unsigned long grib_decode_unsigned_long(const unsigned char* p, long *bitp, long nbits)
> {
>     unsigned long ret = 0;
>     long oc = *bitp/8;
>     unsigned long mask = 0;
>     long pi = 0;
>     int usefulBitsInByte = 0;
>     long bitsToRead = 0;
> 
>     if (nbits==0) return 0;
> 
>     if(nbits > max_nbits)
>     {   
>         int bits = nbits;
>         int mod = bits % max_nbits;
> 
>         if(mod != 0)
>         {
>             int e=grib_decode_unsigned_long(p,bitp,mod);
>             bits -= mod;
>         }
> 
>         while(bits > max_nbits)
>         {
>             int e=grib_decode_unsigned_long(p,bitp,max_nbits);
>             bits -= max_nbits;
>         }
> 
>         return grib_decode_unsigned_long(p,bitp,bits);
>     }   
>     mask = BIT_MASK(nbits);
>     pi = oc; 
>     usefulBitsInByte = 8-(*bitp & 7); 
>     bitsToRead = nbits;
>     while (bitsToRead > 0) {
>         ret  <<= 8;
>         ret = ret | p[pi];
>         pi++;
>         bitsToRead -= usefulBitsInByte;
>         usefulBitsInByte = 8;
>     }   
>     *bitp += nbits;
>     ret >>= -1*bitsToRead;
>     ret &= mask;
>     return ret;
> }
> 
> static double grib_power(long s,long n)
> {
>     double divisor = 1.0;
>     while(s < 0)
>     {   
>         divisor /= n;
>         s++;
>     }   
>     while(s > 0)
>     {   
>         divisor *= n;
>         s--;
>     }   
>     return divisor;
> }
> 
> typedef unsigned long (*encode_float_proc)(double);
> typedef double        (*decode_float_proc)(unsigned long);
> 
> typedef struct ieee_table_t ieee_table_t;
> 
> struct ieee_table_t {
>     int    inited;
>     double e[255];
>     double v[255];
>     double vmin;
>     double vmax;
> };
> 
> static ieee_table_t ieee_table={ 0,{0,},{0,}, 0, 0 };
> 
> static void init_table_if_needed()
> {
>     if (!ieee_table.inited) {
>         unsigned long i;
>         unsigned long mmin=0x800000;
>         unsigned long mmax=0xffffff;
>         double e=1;
>         for (i=1; i<=104;i++) {
>             e*=2;
>             ieee_table.e[i+150]=e;
>             ieee_table.v[i+150]=e*mmin;
>         }
>         ieee_table.e[150]=1;
>         ieee_table.v[150]=mmin;
>         e=1;
>         for (i=1; i<150;i++) {
>             e/=2;
>             ieee_table.e[150-i]=e;
>             ieee_table.v[150-i]=e*mmin;
>         }
>         ieee_table.vmin=ieee_table.v[1];
>         ieee_table.vmax=ieee_table.e[254]*mmax;
>         ieee_table.inited=1;
>     }
> }
> 
> static double grib_long_to_ieee(unsigned long x)
> {
>     unsigned long s = x  & 0x80000000;
>     unsigned long c = (x & 0x7f800000) >> 23;
>     unsigned long m = (x & 0x007fffff);
> 
>     double val;
> 
>     init_table_if_needed();
> 
>     if (c == 0 && m==0) return 0;
> 
>     if (c == 0)  {
>         m |= 0x800000;
>         c=1;
>     } else  m |= 0x800000;
> 
>     val=m*ieee_table.e[c];
>     if(s) val = -val;
> 
>     return val;
> }
> 
> static void binary_search(double xx[], const unsigned long n, double x, unsigned long *j)
> {
>     unsigned long ju,jm,jl;
>     jl=0;
>     ju=n;
>     while (ju-jl > 1) {
>         jm=(ju+jl) >> 1;
>         if (x >= xx[jm]) jl=jm;
>         else ju=jm;
>     }
>     *j=jl;
> }
> 
> 
> static unsigned long grib_ieee_to_long(double x)
> {
>     unsigned long s = 0;
>     unsigned long mmax = 0xffffff;
>     unsigned long mmin = 0x800000;
>     unsigned long m = mmax;
>     unsigned long e=0;
>     double rmmax=mmax+0.5;
> 
>     init_table_if_needed();
> 
>     if (x < 0)  {  s  = 1; x = -x; }
> 
>     /* Underflow */
>     if (x < ieee_table.vmin) {
>         return (s << 31);
>     }
> 
>     /* Overflow */
>     if (x > ieee_table.vmax) {
>         fprintf(stderr, "grib_ieee_to_long: Number is too large: x=%.20e > xmax=%.20e\n", x, ieee_table.vmax);
>         return 0;
>     }
> 
>     binary_search(ieee_table.v, 254, x, &e);
> 
>     x/=ieee_table.e[e];
> 
>     while(x < mmin ) { x *= 2; e--; }
> 
>     while(x > rmmax ) { x /= 2; e++; }
> 
>     m=x+0.5;
> 
>     if ( m > mmax ) { e++; m=0x800000; }
> 
>     return (s << 31) | ( e << 23 ) | ( m & 0x7fffff );
> }
> 
> static unsigned long grib_ieee64_to_long (double x)
> {
>   unsigned long lval;
>   memcpy (&lval, &x, 8);
>   return lval;
> }
> 
> static double grib_long_to_ieee64 (unsigned long x)
> {
>   double dval;
>   memcpy (&dval, &x, 8);
>   return dval;
> }
> 
> 
> static void ellipse (long ni, long nj, long itrunc[], long jtrunc[])
> {
>   const double zeps = 1.E-10;
>   const double zauxil=0.;
>   int i, j;
>   double zi, zj;
> 
> /*
>  * 1. Computing meridional limit wavenumbers along zonal wavenumbers
>  */
> 
>   for (j = 1; j < nj; j++)
>     {
>       zi = (double)ni / (double)nj * sqrt (MAX (zauxil, (double)(nj * nj - j * j)));
>       itrunc[j] = (int)(zi + zeps);
>     }
>   
>   if (nj == 0)
>     {
>      itrunc[0] = ni;
>     }
>   else
>     {
>      itrunc[0] = ni;
>      itrunc[nj] = 0;
>     }
> 
> /*
>  * 2. Computing zonal limit wavenumbers along meridional wavenumbers
>  */
> 
>   for (i = 1; i < ni; i++)
>     {
>       zj = (double)nj / (double)ni * sqrt (MAX (zauxil, (double)(ni * ni - i * i)));
>       jtrunc[i] = (int)(zj + zeps);
>     }
>   
>   if (ni == 0)
>     {
>      jtrunc[0] = nj;
>     }
>   else
>     {
>      jtrunc[0] = nj;
>      jtrunc[ni] = 0;
>     }
> 
> 
> }
> 
> static void rectangle (long ni, long nj, long itrunc[], long jtrunc[])
> {
>   int i, j;
> 
> /*
>  * 1. Computing meridional limit wavenumbers along zonal wavenumbers
>  */
> 
>   for (j = 0; j <= nj; j++)
>     itrunc[j] = ni;
> 
> /*
>  * 2. Computing zonal limit wavenumbers along meridional wavenumbers
>  */
> 
>   for (i = 0; i <= ni; i++)
>     jtrunc[i] = nj;
> 
> }
> 
> static void diamond (long ni, long nj, long itrunc[], long jtrunc[])
> {
>   int i, j;
> 
>   for (j = 0; j <= nj; j++)
>     itrunc[j] = ni - (j * ni) / nj;
> 
>   for (i = 0; i <= ni; i++)
>     jtrunc[i] = nj - (i * nj) / ni;
> 
> }
> 
> #define scals(i,j) pow((double)((i)*(i)+(j)*(j)),bt->laplacianOperator)
> 
> 
> #define for_ij() \
>   for (j = 0; j <= bt->bif_j; j++) \
>   for (i = 0; i <= bt->itruncation_bif[j]; i++)
> 
> #define calc_insub() \
> do {                                                                             \
>       insub = (i <= bt->sub_i) && (j <= bt->sub_j);                              \
>       if (insub)                                                                 \
>         insub = (i <= bt->itruncation_sub[j]) && (j <= bt->jtruncation_sub[i]);  \
>       if (bt->keepaxes)                                                          \
>         insub = insub || (i == 0) || (j == 0);                                   \
> } while (0)
> 
> typedef struct bif_trunc_t
> {
>   long bits_per_value;
>   long decimal_scale_factor;
>   long binary_scale_factor;
>   long ieee_floats;
>   double laplacianOperator;
>   double reference_value;
>   long sub_i, sub_j, bif_i, bif_j;
>   long biFourierTruncationType;
>   long biFourierSubTruncationType;
>   long keepaxes;
>   decode_float_proc decode_float;
>   encode_float_proc encode_float;
>   int bytes;
>   long * itruncation_bif;
>   long * jtruncation_bif;
>   long * itruncation_sub;
>   long * jtruncation_sub;
>   size_t n_vals_bif, n_vals_sub;
> } bif_trunc_t;
> 
> /*
>  * Total number of coefficients
>  */
> static size_t size_bif (bif_trunc_t * bt)
> {
>   size_t n_vals = 0;
>   int j;
>   for (j = 0; j <= bt->bif_j; j++)
>     n_vals += 4 * (bt->itruncation_bif[j] + 1);
>   return n_vals;
> }
> 
> 
> /*
>  * Number of unpacked coefficients
>  */
> static size_t size_sub (bif_trunc_t * bt)
> {
>   size_t n_vals = 0;
>   int i, j;
>   for_ij ()
>     {
>       int insub;
>   
>       calc_insub ();
> 
>       if (insub)
>         n_vals += 4;
>     }
>   return n_vals;
> }
> 
> static
> double laplam (bif_trunc_t * bt, const float val[])
> {
> /*
>  * For bi-Fourier spectral fields, the Laplacian operator is a multiplication by (i*i+j*j)
>  */
> 
>   const double zeps = 1E-15;
>   double * znorm = NULL, * zw = NULL;
>   int kmax = 1 + bt->bif_i * bt->bif_i + bt->bif_j * bt->bif_j, lmax;
>   int * itab1 = NULL, * itab2 = NULL;
>   int i, j, k, l, isp;
>   double zxmw, zymw, zwsum, zx, zy, zsum1, zsum2, zbeta1, zp;
> 
>   itab1 = (int *)malloc (sizeof (int) * kmax);
>   itab2 = (int *)malloc (sizeof (int) * ((1 + bt->bif_i) * (1 + bt->bif_j)));
> 
>   for (k = 0; k < kmax; k++)
>     itab1[k] = 0;
> 
> /*
>  * Keep record of the possible values of i**2+j**2 outside the non-packed truncation
>  */
>   for_ij ()
>     {   
>       int insub;
> 
>       calc_insub ();
> 
>       if (! insub)
>         {
>           int k = i*i+j*j;
>           itab1[k] = 1;
>         }
>     }   
> 
>   l = 0;
>   for (k = 0; k < kmax; k++)
>     if (itab1[k])
>       {
>         itab2[l] = k;
>         itab1[k] = l;
>         l++;
>       }
>   lmax = l;
> 
> 
> /*
>  * Now, itab2 contains all possible values of i*i+j*j, and itab1 contains 
>  * the rank of all i*i+j*j
>  */
> 
>   znorm = (double *)malloc (sizeof (double) * lmax);
>   zw    = (double *)malloc (sizeof (double) * lmax);
> 
> /*
>  * Compute norms of input field, gathered by values of i**2+j**2; we have to 
>  * go through the unpacked truncation again
>  */
> 
>   for (l = 0; l < lmax; l++)
>     znorm[l] = 0.;
> 
>   isp = 0;
>   for_ij ()
>     {   
>       int insub;
> 
>       calc_insub ();
> 
>       if (insub)
>         {
>           isp += 4;
>         }
>       else
>         {
>           int m, l = itab1[i*i+j*j];
>           for (m = 0; m < 4; m++, isp++)
>             znorm[l] = MAX (znorm[l], fabs (val[isp]));
>         }
>     }   
> 
> /*
>  * Compute weights, fix very small norms to avoid problems with log function
>  */
> 
>   for (l = 0; l < lmax; l++)
>     {
>       zw[l] = (double)lmax / (double)(l + 1);
>       if (znorm[l] < zeps)
>         {
>           znorm[l] = zeps;
>           zw[l] = 100. * zeps;
>         }
>     }
> 
> /*
>  * Sum weights
>  */
> 
>   zxmw = 0.;
>   zymw = 0.;
>   zwsum = 0.;
>  
>   for (l = 0; l < lmax; l++)
>     {
>       zx = log (itab2[l]);
>       zy = log (znorm[l]);
>       zxmw += zx * zw[l];
>       zymw += zy * zw[l];
>       zwsum += zw[l];
>     }
> 
> /*
>  * Least square regression
>  */
> 
>   zxmw = zxmw / zwsum;
>   zymw = zymw / zwsum;
>   zsum1 = 0.;
>   zsum2 = 0.;
> 
>   for (l = 0; l < lmax; l++)
>     {
>       zx = log (itab2[l]);
>       zy = log (znorm[l]);
>       zsum1 += zw[l] * (zy - zymw) * (zx - zxmw);
>       zsum2 += zw[l] * (zx - zxmw) * (zx - zxmw);
>     }
> 
>   zbeta1 = zsum1 / zsum2;
>   zp = -zbeta1;
>   zp = MAX (-9.999, MIN (9.999, zp));
> 
>   free (itab1);
>   free (itab2);
> 
>   free (znorm);
>   free (zw);
> 
> //zp = ((long)(zp * 1000.)) / 1000.; FAPULA rounds Laplacian power to 1/1000th
> 
>   return zp;
> }
> 
> static void free_bif_trunc (bif_trunc_t * bt)
> {
>   if (bt == NULL)
>     return;
>   if (bt->itruncation_bif != NULL) free (bt->itruncation_bif);
>   if (bt->jtruncation_bif != NULL) free (bt->jtruncation_bif);
>   if (bt->itruncation_sub != NULL) free (bt->itruncation_sub);
>   if (bt->jtruncation_sub != NULL) free (bt->jtruncation_sub);
>   memset (bt, 0, sizeof (bif_trunc_t));
>   free (bt);
> }
> 
> static bif_trunc_t * new_bif_trunc (unsigned char * s3, unsigned char * s5)
> {
>   bif_trunc_t * bt = (bif_trunc_t *)malloc (sizeof (bif_trunc_t));
> 
>   memset (bt, 0, sizeof (bif_trunc_t));
> 
>   bt->reference_value              = ieee2flt (s5 + 11);
>   bt->bits_per_value               = s5[19];
>   bt->binary_scale_factor          = int2 (s5 + 15);
>   bt->decimal_scale_factor         = int2 (s5 + 17);
>   bt->ieee_floats                  = s5[30];
>   bt->laplacianOperator            = (double)int4 (s5 + 22) / 1e6;
>   bt->sub_i                        = uint2 (s5 + 26);
>   bt->sub_j                        = uint2 (s5 + 28);
>   bt->bif_i                        = uint4 (s3 + 15);
>   bt->bif_j                        = uint4 (s3 + 19);
>   bt->biFourierTruncationType      = s3[23];
>   bt->biFourierSubTruncationType   = s5[20];
>   bt->keepaxes                     = s5[21];
> 
>   switch (bt->ieee_floats) 
>     {
>       case 1:
>         bt->decode_float = grib_long_to_ieee;
>         bt->encode_float = grib_ieee_to_long;
>         bt->bytes        = 4;
>       break;
>       case 2:
>         bt->decode_float = grib_long_to_ieee64;
>         bt->encode_float = grib_ieee64_to_long;
>         bt->bytes        = 8;
>        break;
>       default:
>         goto cleanup;
>   }
> 
>   bt->itruncation_sub = (long *)malloc(sizeof(long)*(1+bt->sub_j));
>   bt->jtruncation_sub = (long *)malloc(sizeof(long)*(1+bt->sub_i));
>   bt->itruncation_bif = (long *)malloc(sizeof(long)*(1+bt->bif_j));
>   bt->jtruncation_bif = (long *)malloc(sizeof(long)*(1+bt->bif_i));
> 
>   switch (bt->biFourierTruncationType) 
>     {
>       case 77: diamond   (bt->bif_i, bt->bif_j, bt->itruncation_bif, bt->jtruncation_bif); break;
>       case 88: rectangle (bt->bif_i, bt->bif_j, bt->itruncation_bif, bt->jtruncation_bif); break;
>       case 99: ellipse   (bt->bif_i, bt->bif_j, bt->itruncation_bif, bt->jtruncation_bif); break;
>       default:
>         goto cleanup;
>     }
>   switch (bt->biFourierSubTruncationType) 
>     {
>       case 77: diamond   (bt->sub_i, bt->sub_j, bt->itruncation_sub, bt->jtruncation_sub); break;
>       case 88: rectangle (bt->sub_i, bt->sub_j, bt->itruncation_sub, bt->jtruncation_sub); break;
>       case 99: ellipse   (bt->sub_i, bt->sub_j, bt->itruncation_sub, bt->jtruncation_sub); break;
>       default:
>         goto cleanup;
>     }
> 
>   bt->n_vals_bif = size_bif (bt);
>   bt->n_vals_sub = size_sub (bt);
> 
>   return bt;
> 
> cleanup:
> 
>   free (bt);
> 
>   return NULL;
> }
> 
> int unpack_bifourier (unsigned char ** sec, float * val) 
> {
>     unsigned char* hres = NULL;
>     unsigned char* lres = NULL;
> 
>     long   hpos = 0;
>     long   lpos = 0;
>     int isp;
>     bif_trunc_t * bt;
>     double s = 0;
>     double d = 0;
>     int ret = 0;
>     int i, j, k;
> 
>     bt = new_bif_trunc (sec[3], sec[5]);
> 
>     if (bt == NULL)
>       {
>         ret = 1;
>         goto cleanup;
>       }
> 
>     s = grib_power (+bt->binary_scale_factor,   2);
>     d = grib_power (-bt->decimal_scale_factor, 10);
> 
> /*
>  * Decode data
>  */
> 
>     hres = sec[7] + 5;
>     lres = sec[7] + 5 + bt->bytes * bt->n_vals_sub;
> 
>     hpos = 0;
>     lpos = 0;
> 
>     isp = 0;
> 
>     for_ij ()
>       {
>         double current_val;
>         int insub;
> 
>         calc_insub ();
> 
>         if (insub)
>           for (k = 0; k < 4; k++)
>             {
>               val[isp+k] = bt->decode_float (grib_decode_unsigned_long (hres, &hpos, 8 * bt->bytes));
>             }
>         else
>           for (k = 0; k < 4; k++)
>             {
>               double S = scals (i, j);
>               long dec_val = grib_decode_unsigned_long (lres, &lpos, bt->bits_per_value);
>               val[isp+k] = (double)(((dec_val * s) + bt->reference_value) * d)/ S;
>             }
> 
>         isp += 4;
>       }
> 
> cleanup:
> 
>     free_bif_trunc (bt);
> 
>     return ret;
> }
> 
> static int pack_bifourier (unsigned char ** sec, float * val, int use_scale) 
> {
>     size_t         buflen = 0;
>     size_t         hsize  = 0;
>     size_t         lsize  = 0;
>     unsigned char* buf  = NULL;
>     unsigned char* hres = NULL;
>     unsigned char* lres = NULL;
>     long   hpos = 0;
>     long   lpos = 0;
>     int isp;
>     bif_trunc_t * bt;
> 
>     double max = 0;
>     double min = 0;
>     int laplacianOperator;
> 
>     int ret = 0;
>     int i, j, k;
>     int minmax_set;
>     double d = 0., s = 0.;
> 
>     bt = new_bif_trunc (sec[3], sec[5]);
> 
>     if (bt == NULL)
>       return 1;
> 
>     bt->laplacianOperator = laplam (bt, val);
>     laplacianOperator = (int)(bt->laplacianOperator * 1e6);
>     int_char (laplacianOperator, &sec[5][22]);
> 
> /*
>  * Scan all values that will be truncated and find their minimum and maximum
>  */
> 
>     minmax_set = 0;
> 
>     isp = 0;
>     for_ij ()
>       {
>         int insub;
>    
>         calc_insub ();
> 
>         if (! insub)
>           {
>             for (k = 0; k < 4; k++)
>               {
>                 double current_val = val[isp+k] * scals (i, j);
>                 if (! minmax_set)
>                   {
>                     min = current_val;
>                     max = current_val;
>                     minmax_set++;
>                   }
>                 if (current_val < min) min = current_val;
>                 if (current_val > max) max = current_val;
>               }
>           }
> 
>         isp += 4;
>       }
> 
>     if (bt->n_vals_bif != bt->n_vals_sub)
>       {
>         double S = 1;
> 
>         bt->reference_value = min;
> 
> 	if (! use_scale)
>           {
>             bt->decimal_scale_factor = 0;
>             bt->binary_scale_factor  = -bt->bits_per_value;
>             
>             while (1)
>               {
>                 if ((max - min) / S < 1)
>                   break;
>                 S *= 2;
>                 bt->binary_scale_factor++;
>               }
> 	  }
> 
>         s = grib_power (-bt->binary_scale_factor,   2);
>         d = grib_power (+bt->decimal_scale_factor, 10);
> 	if (bt->decimal_scale_factor!=0)
> 	    bt->reference_value =bt->reference_value*d;
>      }
>    else
>      {
>        bt->decimal_scale_factor = 0;
>        bt->binary_scale_factor  = 0;
>        bt->reference_value      = 0.;
>      }
> 
> /*
>  * Encode values
>  */
>     printf("dec_scale=%d binscale=%d refval=%f s=%f d=%f\n",bt->decimal_scale_factor,bt->binary_scale_factor,bt->reference_value,s,d);
>     hsize = bt->bytes * bt->n_vals_sub;
>     lsize = ((bt->n_vals_bif - bt->n_vals_sub) * bt->bits_per_value) / 8;
> 
>     buflen = hsize + lsize;
> 
>     sec[7] = (unsigned char*)malloc (5 + buflen);
> 
>     buf = &sec[7][5];
> 
>     hres = buf;
>     lres = buf + hsize;
> 
>     lpos = 0;
>     hpos = 0;
> 
>     isp = 0;
> 
>     for_ij ()
>       {
>         double current_val;
>         int insub;
> 
>         calc_insub ();
> 
>         if (insub)
>           for (k = 0; k < 4; k++)
>             {
>               current_val = val[isp+k];
>               grib_encode_unsigned_long (hres, bt->encode_float (current_val) , &hpos, 8 * bt->bytes);
>             }
>         else
>           for (k = 0; k < 4; k++)
>             {
>               double S = scals (i, j);
>               current_val = (((((val[isp+k] * d) * S) - bt->reference_value) * s) + 0.5);
>               grib_encode_unsigned_long (lres, current_val, &lpos, bt->bits_per_value);
>             }
> 
>         isp += 4;
> 
>       }
> 
>     if (((hpos / 8) != hsize) && ((lpos / 8) != lsize))
>       {
>         ret = 0;
>         goto cleanup;
>       }
> 
>     buflen = ((hpos + lpos)/8);
>     sec[7][4] = 7;
>     uint_char (buflen + 5, &sec[7][0]);
>     
>     flt2ieee  (bt->reference_value,      &sec[5][11]);
>     int2_char (bt->binary_scale_factor,  &sec[5][15]);
>     int2_char (bt->decimal_scale_factor, &sec[5][17]);
> 
> cleanup:
> 
>     free_bif_trunc (bt);
> 
>     return ret;
> }
> 
> static unsigned char * dup_sec (unsigned char * sec)
> {
>   int size = uint4 (&sec[0]);
>   unsigned char * Sec = (unsigned char *) malloc (size);
>   memcpy (Sec, sec, size);
>   return Sec;
> }
> 
> int bifourier_grib_out (unsigned char **sec, float *data, unsigned int ndata, 
>     int use_scale, int dec_scale, int bin_scale, int wanted_bits, 
>     int max_bits, struct seq_file *out) 
> {
>   int i;
>   unsigned char * Sec[7];
> 
>   Sec[0] = sec[0];
>   Sec[1] = sec[1];
>   Sec[2] = sec[2];
>   Sec[3] = sec[3];
>   Sec[4] = sec[4];
>   Sec[5] = dup_sec (sec[5]);
>   Sec[6] = dup_sec (sec[6]);
>   Sec[7] = NULL;
> 
>   Sec[5][19] = max_bits;
> 
>   if (use_scale)
>     {
>       int2_char (bin_scale, &Sec[5][15]);
>       int2_char (dec_scale, &Sec[5][17]);
>     }
> 
>   pack_bifourier (Sec, data, use_scale);
> 
>   i = wrt_sec (Sec[0], Sec[1], Sec[2], Sec[3], Sec[4], Sec[5], Sec[6], Sec[7], out);
> 
>   free (Sec[5]);
>   free (Sec[7]);
> 
>   return i;
> }
> 
> 
> 
> 
> 
> 
> 
> 
diff -N wgrib2/bifourier.h ../../wgrib2_mod/grib2/wgrib2/bifourier.h
0a1,12
> #ifndef _BIFOURIER_H
> #define _BIFOURIER_H
> 
> #include "grb2.h"
> #include "fnlist.h"
> 
> extern int unpack_bifourier (unsigned char **, float *);
> extern int bifourier_grib_out (unsigned char **, float *, unsigned int, 
>                                int, int, int, int, int, struct seq_file *);
> 
> 
> #endif
diff -N wgrib2/CodeTable_3.1.dat ../../wgrib2_mod/grib2/wgrib2/CodeTable_3.1.dat
16a17,19
>     case 61: string="Spectral LAM Mercator"; break;
>     case 62: string="Spectral LAM PolarStereographic"; break;
>     case 63: string="Spectral LAM Lambert"; break;
diff -N wgrib2/CodeTable_5.0.dat ../../wgrib2_mod/grib2/wgrib2/CodeTable_5.0.dat
10a11
>     case 53: string="spectral bifourier data - complex packing"; break;
diff -N wgrib2/config.h ../../wgrib2_mod/grib2/wgrib2/config.h
6,7c6
< #define USE_IPOLATES
< #define IPOLATES_LIB "iplib.2012"
---
> //#define USE_IPOLATES
12c11
< //#define USE_NETCDF3
---
> #define USE_NETCDF3
15,17c14,15
< #define USE_OPENMP
< #define CC "gcc (GCC) 4.4.7 20120313 (Red Hat 4.4.7-17)"
< #define FORTRAN "gfortran"
---
> #define CC "cc"
> #define FORTRAN "f77"
diff -N wgrib2/fnlist ../../wgrib2_mod/grib2/wgrib2/fnlist
0a1,324
> 400:0xSec:inv:1:Hex dump of section X (0..8)
> 200:aerosol_size:inv:0:optical properties of an aerosol
> 200:aerosol_wavelength:inv:0:optical properties of an aerosol
> 700:bitmap:inv:0:bitmap mode
> 110:center:inv:0:center 
> 400:checksum:inv:1:CRC checksum of section X (0..8), whole message (X = -1/message) or (X=data)
> -1:code_table_0.0:inv:0:code table 0.0 discipline
> -1:code_table_1.0:inv:0:code table 1.0 master table version
> -1:code_table_1.1:inv:0:code table 1.1 local table version
> -1:code_table_1.2:inv:0:code table 1.2 significance of reference time
> -1:code_table_1.3:inv:0:code table 1.3 production status of processed data
> -1:code_table_1.4:inv:0:code table 1.4 type of processed data
> -1:code_table_1.5:inv:0:Identification template number
> -1:code_table_1.6:inv:0:calendar
> -1:code_table_3.0:inv:0:code table 3.0 Source of grid definition
> -1:code_table_3.1:inv:0:code table 3.1 Grid definition template number
> -1:code_table_3.11:inv:0:code table 3.11 regional/global thinned/reduced grid
> -1:code_table_3.15:inv:0:code table 3.15 Physical meaning of vertical coordinate
> -1:code_table_3.2:inv:0:code table 3.2 Size (radius) and Shape of Earth
> -1:code_table_3.20:inv:0:code table 3.20 Type of Horizontal line
> -1:code_table_3.21:inv:0:code table 3.21 Vertical Dimension coordinate values defn
> -1:code_table_3.6:inv:0:code table 3.6 Spectral data representation type
> -1:code_table_3.7:inv:0:code table 3.7 Spectral data representation mode
> -1:code_table_3.8:inv:0:code table 3.8 Grid point position
> -1:code_table_4.0:inv:0:code table 4.0 Product Definition Template Number
> -1:code_table_4.1:inv:0:code table 4.1
> -1:code_table_4.10:inv:0:code table 4.10 statistical processing .. first occurence
> -1:code_table_4.11:inv:0:code table 4.11 (first) type of time intervals
> -1:code_table_4.11s:inv:0:code table 4.11 (all) type of time intervals
> -1:code_table_4.15:inv:0:code table 4.15 type of areal statistical processing
> -1:code_table_4.2:inv:0:code table 4.2
> -1:code_table_4.230:inv:0:code table 4.230 chemical constituent type
> -1:code_table_4.233:inv:0:code table 4.233 aerosol type
> -1:code_table_4.235:inv:0:code table 4.235 Wind-generated wave spectral description
> -1:code_table_4.240:inv:0:code table 4.240 Type of distribution function
> -1:code_table_4.3:inv:0:code table 4.3 Type of Generating Process
> -1:code_table_4.4:inv:0:code table 4.4  (first)
> -1:code_table_4.5a:inv:0:code table 4.5 (1st value)
> -1:code_table_4.5b:inv:0:code table 4.5 (2nd value)
> -1:code_table_4.6:inv:0:code table 4.6 ensemble type
> -1:code_table_4.7:inv:0:code table 4.7 derived forecast
> -1:code_table_4.8:inv:0:code table 4.7 derived forecast
> -1:code_table_4.9:inv:0:code table 4.9 Probability Type
> -1:code_table_4.91:inv:0:code table 4.91 type of interval
> -1:code_table_4.91b:inv:0:code table 4.91 type of interval (2nd copy)
> -1:code_table_5.0:inv:0:code table 5.0 data representation number
> -1:code_table_5.1:inv:0:code table 5.1 type of original field values
> -1:code_table_5.4:inv:0:code table 5.4 group splitting method
> -1:code_table_5.5:inv:0:code table 5.5 missing value management for complex packing
> -1:code_table_5.6:inv:0:code table 5.5 complex packing spatial differencing
> -1:code_table_5.7:inv:0:code table 5.7 precision in IEEE packing
> -1:code_table_6.0:inv:0:code table 6.0 Bitmap indicator
> -1:ctl_ens:inv:0:ens info for g2ctl/GrADS
> -1:ctl_inv:inv:0:ctl inventory dump for g2ctl/GrADS
> -1:cyclic:inv:0:is grid cyclic? (not for thinned grids)
> 200:disc=f_code_table_0_0:inv:0:discipline (code table 0.0)
> 100:domain:inv:0:find rectangular domain for g2ctl/GrADS plots
> 400:end_ft:inv:0:verf time = reference_time + forecast_time + stat. proc time (YYYYMMDDHH) (same as -vt)
> 400:end_FT:inv:0:verf time = reference_time + forecast_time + stat. proc time (YYYYMMDDHHMMSS) (same as -VT)
> 200:ens:inv:0:ensemble information
> 400:ext_name:inv:0:extended name, var+qualifiers
> -1:flag_table_3.10:inv:0:flag table 3.10 scanning mode for one diamond
> -1:flag_table_3.3:inv:0:flag table 3.3, resolution and component flags
> -1:flag_table_3.4:inv:0:flag table 3.4, scanning mode
> -1:flag_table_3.5:inv:0:flag table 3.5 projection center
> -1:flag_table_3.9:inv:0:flag table 3.9 numbering order of diamonds seen from corresponding pole
> 440:ftime:inv:0:forecast time
> 100:ftn_api_fn0:inv:0:n npnts nx ny msg_no submsg i8,5(1x,i8)
> 400:full_name:inv:0:extended name, var+qualifiers
> 200:gdt:inv:0:contents of Grid Definition Template (g2c)
> 100:get_byte:inv:3:get bytes in Section X, Octet Y, number of bytes Z (decimal format)
> 100:get_hex:inv:3:get bytes in Section X, Octet Y, number of bytes Z (bytes in hexadecimal format)
> 100:get_ieee:inv:3:get ieee float in Section X, Octet Y, number of floats Z
> 100:get_int:inv:3:get 4-byte ints in Section X, Octet Y, number of ints Z
> 100:get_int2:inv:3:get 2-byte ints in Section X, Octet Y, number of ints Z
> 200:grid:inv:0:grid definition
> 100:grid_id:inv:0:show values from grid_id
> 400:hybrid:inv:0:shows vertical coordinate parameters from Sec4
> 100:ij:inv:2:value of field at grid(X,Y) X=1,..,nx Y=1,..,ny (WxText enabled)
> 100:ijlat:inv:2:lat,lon and grid value at grid(X,Y) X=1,..,nx Y=1,..,ny (WxText enabled)
> 100:ilat:inv:1:lat,lon and grid value at Xth grid point, X=1,..,npnts (WxText enabled)
> 400:JMA:inv:0:inventory for JMA locally defined PDT
> 200:lev:inv:0:level (code table 4.5)
> -1:lev0:inv:0:level for g2ctl/GrADS
> 100:ll2i:inv:2:x=lon y=lat, converts to (i), 1..ndata
> 100:ll2ij:inv:2:x=lon y=lat, converts lon-lat to (i,j) using gctpc
> 100:lon:inv:2:value at grid point nearest lon=X lat=Y (WxText enabled)
> 100:match_inv:inv:0:inventory used by -match, -not, -if and -not_if
> 100:max:inv:0:print maximum value
> 100:min:inv:0:print minimum value
> 100:misc:inv:0:variable name qualifiers like chemical, ensemble, probability, etc
> 105:MM:inv:0:reference time MM
> 100:model_version_date:inv:0:prints model date code
> 100:n:inv:0:prints out inventory number
> 200:N_ens:inv:0:number of ensemble members
> 100:nl:inv:0:inserts new line into inventory
> 200:nlons:inv:0:number of longitudes for each latitude
> 500:npts:inv:0:number of grid points
> 200:nxny:inv:0:nx and ny of grid
> 510:packing:inv:0:shows the packing mode (use -v for more details)
> -1:pds_fcst_time:inv:0:fcst_time(1) in units given by pds
> 400:pdt:inv:0:Product Definition Table (Code Table 4.0)
> -1:percent:inv:0:percentage probability
> 100:print:inv:1:inserts string (X) into inventory
> 100:prob:inv:0:probability information
> 200:process=f_code_table_4_3:inv:0:Process (code table 4.3)
> 400:processid:inv:0:process id (locally defined)
> 100:proj4_ij2ll:inv:2:X=x Y=y, converts to (i,j) to lon-lat using proj.4  (experimental) we:sn
> 100:proj4_ll2i:inv:2:x=lon y=lat, converts to (i) using proj.4  (experimental) 1..ndata
> 100:proj4_ll2ij:inv:2:x=lon y=lat, converts lon-lat (i,j) using proj.4 (experimental)
> 100:radius:inv:0:radius of Earth
> 100:range:inv:0:print out location of record in bytes, 0 = first byte
> 110:RT:inv:0:type of reference Time
> 100:s:inv:0:simple inventory
> 100:S:inv:0:simple inventory with minutes and seconds (subject to change)
> 510:scale:inv:0:scale for packing
> 510:scaling:inv:0:scaling for packing (old format)
> 200:scan:inv:0:scan order of grid
> 200:Sec0:inv:0:contents of section0
> 200:Sec3:inv:0:contents of section 3 (Grid Definition Section)
> 400:Sec4:inv:0:Sec 4 values (Product definition section)
> 400:Sec5:inv:0:Sec 5 values (Data representation section)
> 700:Sec6:inv:0:show bit-map section
> 700:Sec_len:inv:0:length of various grib sections
> 400:spatial_proc:inv:0:show spacial processing, pdt=4.15
> 400:spectral_bands:inv:0:spectral bands for satellite, pdt=4.31 or 4.32
> -1:spectral_bands_extname:inv:0:spectral bands for satellite, pdt=4.31 or 4.32, concise name for ExtName
> 400:start_ft:inv:0:verf time = reference_time + forecast_time (YYYYMMDDHH) : no stat. proc time
> 400:start_FT:inv:0:verf time = reference_time + forecast_time (YYYYMMDDHHMMSS) - no stat. proc time
> 100:stats:inv:0:statistical summary of data values
> 110:subcenter:inv:0:subcenter 
> 100:t:inv:0:reference time YYYYMMDDHH, -v2 for alt format
> 101:T:inv:0:reference time YYYYMMDDHHMMSS
> 200:table:inv:0:parameter table
> 100:unix_time:inv:0:print unix timestamp for rt & vt
> 100:V:inv:0:diagnostic output
> 400:var:inv:0:short variable name
> 400:varX:inv:0:raw variable name - discipline mastertab localtab center parmcat parmnum
> 1:vector_dir:inv:0:grid or earth relative winds
> 100:verf:inv:0:simple inventory using verification time
> 400:vt:inv:0:verf time = reference_time + forecast_time, -v2 for alt format
> 400:VT:inv:0:verf time = reference_time + forecast_time (YYYYMMDDHHMMSS)
> 200:wave_partition:inv:0:ocean surface wave partition (pdt=4.52)
> 103:YY:inv:0:reference time YYYY
> 100:inv_f77:inv_output:3:match inventory written to Z with character*(Y) and X=(bin,ieee)
> 100:last:inv_output:1:write last inv item to file X
> 100:last0:inv_output:1:write last inv item to beginning of file X
> 100:nl_out:inv_output:1:write new line in file X
> 100:print_out:inv_output:2:prints string (X) in file (Y)
> 100:s_out:inv_output:1:simple inventory written to X
> 100:big_endian:misc:0:sets ieee output to big endian (default is big endian)
> 100:colon:misc:1:replace item deliminator (:) with X
> 100:config:misc:0:shows the configuration
> 100:count:misc:0:prints count, number times this -count was processed
> 100:end:misc:0:stop after first (sub)message (save time)
> 100:error_final:misc:3:error if at end X=count Y=ne,eq,le,lt,gt,ge Z=integer 
> 100:fix_CFSv2_fcst:misc:3:fixes CFSv2 monthly fcst  X=daily or 00/06/12/18 Y=pert no. Z=number ens fcsts  v1.0
> 100:fix_ncep:misc:0:fix ncep PDT=8 headers produced by cnvgrib
> 100:gctpc:misc:1: X=0,1 use gctpc library  (default=1)
> 100:grid_changes:misc:0:prints number of grid changes
> 100:grid_def:misc:0:read lon and lat data from grib file -- experimental
> 100:h:misc:0:help, shows common options
> 100:header:misc:0:f77 header or nx-ny header in text output (default)
> 100:help:misc:1:help [search string|all], -help all, shows all options
> 100:if:misc:1:if X (POSIX regular expression) matches, conditional execution up to next output/fi
> 100:if_fs:misc:1:if X (fixed string) matches, conditional execution up to next output/fi
> 100:if_n:misc:1:if (inv numbers in range),  X=(start:end:step)
> 100:if_rec:misc:1:if (record numbers in range),  X=(start:end:step)
> 100:if_reg:misc:1:if rpn registers defined, X = A, A:B, A:B:C, etc A = register number
> 100:ijundefine:misc:3:sets grid point values to undefined X=(in-box|out-box) Y=ix0:ix1 Z=iy0:iy1  ix=(1..nx) iy=(1..ny)
> 100:import_bin:misc:1:read binary file (X) for data
> 100:import_grib:misc:1:read grib2 file (X) for data
> 100:import_ieee:misc:1:read ieee file (X) for data
> 100:import_text:misc:1:read text file (X) for data
> 100:limit:misc:1:stops after X fields decoded
> 100:little_endian:misc:0:sets ieee output to little endian (default is big endian)
> 100:mem_del:misc:1:delete mem file X
> 100:mem_final:misc:2:write mem file X to file Y at cleanup step
> 100:mem_init:misc:2:read mem file X from file Y (on initialization)
> 111:new_grid_interpolation:misc:1:new_grid interpolation X=bilinear,bicubic,neighbor,budget
> 111:new_grid_ipopt:misc:1:new_grid ipopt values X=i1:i2..:iN N <= 20
> 111:new_grid_vectors:misc:1:change fields to vector interpolate: X=none,default,UGRD:VGRD,(U:V list)
> 111:new_grid_winds:misc:1:new_grid wind orientation: X = grid, earth (no default)
> 100:no_header:misc:0:no f77 header or nx-ny header in text output
> 100:not_if:misc:1:if X (regular expression) does not match, conditional execution until next output/fi
> 100:not_if_fs:misc:1:if X (fixed string) does not match, conditional execution up to next output/fi
> 100:proj4:misc:1:X=0,1 use proj4 library for geolocation (testing)
> -1:quit=f_end:misc:0:stop after first (sub)message (save time)
> 100:rewind_final:misc:1:rewinds file X on cleanup step if already opened, CW2
> 100:rewind_proc:misc:1:rewinds file X on processing step if already opened, CW2
> 100:rpn:misc:1:reverse polish notation calculator
> 100:rpn_rcl:misc:1:data = register X .. same as -rpn rcl_X .. no geolocation calc needed
> 100:rpn_sto:misc:1:register X = data.. same as -rpn sto_X .. no geolocation calc needed
> 100:set:misc:2:set X = Y, X=local_table,etc (help: -set help help)
> 100:set_ave:misc:1:set ave/acc .. only on pdt=4.0 only anl/fcst
> 100:set_bin_prec:misc:1:X set number of binary bits for grib_out packing
> 100:set_bitmap:misc:1:use bitmap when creating complex packed files X=1/0
> 100:set_byte:misc:3:set bytes in Section X, Octet Y, bytes Z (a|a:b:c)
> -1:set_center:misc:1:changes center X = C or C:S     C and S are center/subcenter numbers
> 100:set_date:misc:1:changes date code, X=(+|-)N(hr|dy|mo|yr), YYYYMMDDHHmmSS
> 100:set_ensm_derived_fcst:misc:2:convert PDT 0,1,2 -> 2, 8,11,12 -> 12, X=code table 4.7 Y=num ens members
> 100:set_ens_num:misc:3:convert PDT 0,1 -> 1,  8,11 -> 11, X=code table 4.6 Y=pert num Z=num ens members -1=No Change
> -1:set_flag_table_3.3:misc:1:flag table 3.3 = X
> -1:set_flag_table_3.4:misc:1:flag table 3.4 = X
> 100:set_ftime:misc:1:set ftime
> 100:set_grib_max_bits:misc:1:sets scaling so number of bits does not exceed N in (new) grib output
> 100:set_grib_type:misc:1:set grib type = jpeg, simple, ieee, complex(1|2|3), aec, same
> 100:set_hex:misc:3:set bytes in Section X, Octet Y, bytes Z (a|a:b:c) in hexadecimal
> 100:set_ieee:misc:3:set ieee float in Section X, Octet Y, floats Z (a|a:b:c)
> 100:set_ijval:misc:3:sets grid point value X=ix Y=iy Z=val
> 100:set_int:misc:3:set 4-byte ints in Section X, Octet Y, signed integers Z (a|a:b:c)
> 100:set_int2:misc:3:set 2-byte ints in Section X, Octet Y, signed integers Z (a|a:b:c)
> 100:set_ival:misc:2:sets grid point value X=i1:i2:.. Y=va1:val2:.. grid[i1] = val1,etc
> 100:set_lev:misc:1:changes level code .. not complete
> 100:set_metadata:misc:1:read meta-data for grib writing from file X
> 100:set_metadata_str:misc:1:X = metadata string
> 100:set_pdt:misc:1:makes new pdt, X=(+)PDT_number or X=(+)PDT_number:size of PDT in octets, +=copy metadata
> 100:set_percentile:misc:1:convert PDT 0..6 -> 6, 8..15 -> 10, X=percentile (0..100)
> 100:set_prob:misc:5:X/Y forecasts Z=Code Table 4.9 A=lower limit B=upper limit
> 100:set_radius:misc:1:set radius of Earth  X= 0,2,4,5,6,8,9 (Code Table 3.2), 1:radius , 7:major:minor
> 100:set_scaling:misc:2:set decimal scaling=X/same binary scaling=Y/same  new grib messages
> 100:set_sec_size:misc:2:resizes section , X=section number, Y=size in octets, DANGEROUS
> 100:set_ts_dates:misc:3:changes date code for time series X=YYYYMMDDHH(mmss) Y=dtime Z=#msgs/date
> 100:set_var:misc:1:changes variable name
> 100:status:misc:1:X  arbitrary
> 100:submsg:misc:1:process submessage X (0=process all messages)
> 100:sys:misc:1:run system/shell command, X=shell command
> 100:text_col:misc:1:number of columns on text output
> 100:text_fmt:misc:1:format for text output (C)
> 100:udf:misc:2:run UDF, X=program+optional_args, Y=return file
> 100:udf_arg:misc:2:add grib-data to UDF argument file, X=file Y=name
> 100:undefine:misc:3:sets grid point values to undefined X=(in-box|out-box) Y=lon0:lon1 Z=lat0:lat1
> 100:undefine_val:misc:1:grid point set to undefined if X=val or X=low:high
> 100:v:misc:0:verbose (v=1)
> 100:v0:misc:0:not verbose (v=0)
> -1:v1=f_v:misc:0:verbose (v=1)
> 100:v2:misc:0:really verbose (v=2)
> -1:v97:misc:0:verbose mode for debugging only (v=98) 
> -1:v98:misc:0:verbose mode for debugging only (v=98) 
> -1:v99:misc:0:verbose mode for debugging only (v=99) 
> 100:version:misc:0:print version
> 200:-version=f_version:misc:0:print version
> 100:AAIG:output:0:writes Ascii ArcInfo Grid file, lat-lon grid only (alpha)
> 100:AAIGlong:output:0:writes Ascii ArcInfo Grid file, lat-lon grid only long-name *.asc (alpha)
> 000:ave:output:2:average X=time step, Y=output grib file needs file is special order
> 100:bin:output:1:write binary data to X
> 111:cress_lola:output:4:lon-lat grid values X=lon0:nlon:dlon Y=lat0:nlat:dlat Z=file A=radius1:radius2:..:radiusN
> 100:csv:output:1:make comma separated file, X=file (WxText enabled)
> 100:csv_long:output:1:make comma separated file, X=file (WxText enabled)
> 000:fcst_ave:output:2:average X=time step, Y=output grib file needs file is special order
> 100:fi:output:0:null output operation
> 100:grib:output:1:writes GRIB record (one submessage) to X
> 100:GRIB:output:1:writes entire GRIB record (all submessages)
> 100:grib_ieee:output:1:writes data[] to X.grb, X.head, X.tail, and X.h
> 100:grib_out:output:1:writes decoded/modified data in grib-2 format to file X
> 100:grib_out_irr:output:2:writes irregular grid grib  X=(all|defined) Y=(output file)
> 100:gridout:output:1:text file with grid: i j lat lon (1st record)
> 100:ieee:output:1:write (default:big-endian) IEEE data to X
> 100:ijbox:output:4:grid values in bounding box  X=i1:i2[:di] Y=j1:j2[:dj] Z=file A=[bin|text|spread]
> 100:ijsmall_grib:output:3:make small domain grib file X=ix0:ix1 Y=iy0:iy1 Z=file
> 100:irr_grid:output:3:make irregular grid, nearest neighbor, X=lon-lat list Y=radius (km) Z=output grib file
> 100:lola:output:4:lon-lat grid values X=lon0:nlon:dlon Y=lat0:nlat:dlat Z=file A=[bin|text|spread|grib]
> 100:merge_fcst:output:2:merge forecast ave/acc/min/max X=number to intervals to merge (0=every) Y=output grib file
> 100:mysql:output:5:H=[host] U=[user] P=[password] D=[db] T=[table] (alpha)
> 100:mysql_dump:output:7:H=[host] U=[user] P=[password] D=[db] T=[table] W=[western_lons:0|1] PV=[remove unlikely:0|1]
> 100:mysql_speed:output:7:H=[host] U=[user] P=[password] D=[db] T=[table] W=[western_lons:0|1] PV=[remove unlikely:0|1]
> 100:ncep_norm:output:1:normalize NCEP-type ave/acc X=output grib file
> 111:ncep_uv:output:1:combine U and V fields into one message like NCEP operations
> 100:netcdf:output:1:write netcdf data to X
> 111:new_grid:output:4:bilinear interpolate: X=projection Y=x0:nx:dx Z=y0:ny:dy A=grib_file alpha
> 100:small_grib:output:3:make small domain grib file X=lonW:lonE Y=latS:latN Z=file
> 100:spread:output:1:write text - spread sheet format into X (WxText enabled)
> 111:submsg_uv:output:1:combine vector fields into one message
> 100:text:output:1:write text data into X
> 100:tosubmsg:output:1:convert GRIB message to submessage and write to file X
> 100:wind_dir:output:1:calculate wind direction, X = output gribfile (direction in degrees, 0=wind from north, 90=wind from east)
> 100:wind_speed:output:1:calculate wind speed, X = output gribfile (U then V in datafile)
> 100:append:setup:0:append mode, write to existing output files
> 100:crlf:setup:0:make the end of the inventory a crlf (windows) instead of newline (unix)
> 200:d:setup:1:dump message X (n or n.m), only 1 -d allowed
> 100:egrep:setup:1:egrep X | wgrib2 (X is POSIX regular expression)
> 100:egrep_v:setup:1:egrep -v X | wgrib2 (X is POSIX regular expression)
> 100:eof_bin:setup:2:send (binary) integer to file upon EOF: X=file Y=integer
> 100:eof_string:setup:2:send string to file upon EOF: X=file Y=string
> 100:err_bin:setup:2:send (binary) integer to file upon err exit: X=file Y=integer
> 100:err_string:setup:2:send string to file upon err exit: X=file Y=string
> 100:fgrep:setup:1:fgrep X | wgrib2
> 100:fgrep_v:setup:1:fgrep -v X | wgrib2
> 100:fix_ncep_2:setup:0:ncep bug fix 2, probability observation < -ve number
> 200:fix_ncep_3:setup:0:sets flag to fix ncep bug 3 (constant fields)
> 100:fix_ncep_4:setup:0:fixes NCEP grib2 files where DX and DY are undefined
> -1:flush:setup:0:flush output buffers after every write (interactive)
> 100:for:setup:1:process record numbers in range,  X=(start:end:step), only one -for allowed
> 100:for_n:setup:1:process inv numbers in range,  X=(start:end:step), only one -for allowed
> 100:g2clib:setup:1:X=0/1/2 0=WMO std 1=emulate g2clib 2=use g2clib
> 100:i:setup:0:read Inventory from stdin
> 100:i_file:setup:1:read Inventory from file
> 100:inv:setup:1:write inventory to X
> 100:match:setup:1:process data that matches X (POSIX regular expression)
> 100:match_fs:setup:1:process data that matches X (fixed string)
> 100:nc3:setup:0:use netcdf3 (classic)
> 100:nc4:setup:0:use netcdf4 (compressed, controlled endianness etc)
> 100:nc_grads:setup:0:require netcdf file to be grads v1.9b4 compatible (fixed time step only)
> 100:nc_nlev:setup:1:netcdf, X = max LEV dimension for {TIME,LEV,LAT,LON} data
> 100:nc_pack:setup:1:pack/check limits of all NEW input variables, X=min:max[:byte|short|float]
> 100:ncpu:setup:1:number of threads, default is environment variable OMP_NUM_THREADS/number of cpus
> 100:nc_table:setup:1:X is conversion_to_netcdf_table file name
> 100:nc_time:setup:1:netcdf, [[-]yyyymmddhhnnss]:[dt{s[ec]|m[in]|h[our]|d[ay]}], [-] is for time alignment only
> 100:no_append:setup:0:not append mode, write to new output files (default)
> -1:no_flush:setup:0:flush output buffers when full (default)
> 100:no_nc_grads:setup:0:netcdf file may be not grads v1.9b4 compatible, variable time step
> 100:no_nc_pack:setup:0:no packing in netcdf for NEW variables
> 100:no_nc_table:setup:0:disable previously defined conversion_to_netcdf_table
> 100:no_nc_time:setup:0:netcdf, disable previously defined initial or relative date and time step
> 100:not:setup:1:process data that does not match X (POSIX regular expression)
> 100:not_fs:setup:1:process data that does not match X (fixed string)
> 100:one_line:setup:0:puts all on one line (makes into inventory format)
> 200:order:setup:1:decoded data in X (raw|we:sn|we:ns) order, we:sn is default
> 100:persistent:setup:1:makes file X persistent if already opened (default on open), CW2
> 100:rewind_init:setup:1:rewinds file X on initialization if already opened, CW2
> 400:set_ext_name:setup:1:X=0/1 extended name on/off
> 100:set_regex:setup:1:set regex mode X = 0:extended regex (default) 1:pattern 2:extended regex & quote metacharacters 
> 100:tigge:setup:0:use modified-TIGGE grib table
> 100:transient:setup:1:make file X transient, CW2
diff -N wgrib2/grb2.h ../../wgrib2_mod/grib2/wgrib2/grb2.h
62a63,67
> #define GDS_Lambert_LAM_Nux(gds)        (uint4(gds+81))
> #define GDS_Lambert_LAM_Ncx(gds)        (uint4(gds+85))
> #define GDS_Lambert_LAM_Nuy(gds)        (uint4(gds+89))
> #define GDS_Lambert_LAM_Ncy(gds)        (uint4(gds+93))
> 
127a133,136
> #define GDS_Mercator_LAM_Nux(gds)       (uint4(gds+72))
> #define GDS_Mercator_LAM_Ncx(gds)       (uint4(gds+76))
> #define GDS_Mercator_LAM_Nuy(gds)       (uint4(gds+80))
> #define GDS_Mercator_LAM_Ncy(gds)       (uint4(gds+84))
138a148,151
> #define GDS_Polar_LAM_Nux(gds)          (uint4(gds+65))
> #define GDS_Polar_LAM_Ncx(gds)          (uint4(gds+69))
> #define GDS_Polar_LAM_Nuy(gds)          (uint4(gds+73))
> #define GDS_Polar_LAM_Ncy(gds)          (uint4(gds+77))
189a203,246
> 
> #define GDS_SpectralLAM_N(gds)		uint4(gds+15)
> #define GDS_SpectralLAM_M(gds)		uint4(gds+19)
> #define GDS_SpectralLAM_code_3_6(gds)       ((int) gds[14])
> #define GDS_SpectralLAM_code_3_25(gds)       ((int) gds[23])
> #define GDS_SpectralLAM_Lx(gds)		uint8(gds+24)
> #define GDS_SpectralLAM_Lux(gds)	uint8(gds+32)
> #define GDS_SpectralLAM_Lcx(gds)	uint8(gds+40)
> #define GDS_SpectralLAM_Ly(gds)		uint8(gds+48)
> #define GDS_SpectralLAM_Luy(gds)	uint8(gds+56)
> #define GDS_SpectralLAM_Lcy(gds)	uint8(gds+64)
> 
> #define GDS_SpectralLAM_code_3_2(gds)	((int)(gds[72])
> #define GDS_SpectralLAM_scaleFactorOfRadius(gds)	((int)(gds[73])
> #define GDS_SpectralLAM_scaledValueOfRadius(gds)	uint4(gds+74)
> #define GDS_SpectralLAM_scaleFactorOfMajorAxis(gds)	((int)(gds[78])
> #define GDS_SpectralLAM_scaledValueOfMajorAxis(gds)	uint4(gds+79)
> #define GDS_SpectralLAM_scaleFactorOfMinorAxis(gds)	((int)(gds[83])
> #define GDS_SpectralLAM_scaledValueOfMinorAxis(gds)	uint4(gds+84)
> 
> #define GDS_SpectralLAM_mercator_La1(gds)	int4(gds+88)
> #define GDS_SpectralLAM_mercator_Lo1(gds)	int4(gds+92)
> #define GDS_SpectralLAM_mercator_LaD(gds)	int4(gds+96)
> #define GDS_SpectralLAM_mercator_La2(gds)	int4(gds+100)
> #define GDS_SpectralLAM_mercator_Lo2(gds)	int4(gds+104)
> #define GDS_SpectralLAM_mercator_gridOrientation(gds)	int4(gds+108)
> 
> #define GDS_SpectralLAM_polarStereo_La1(gds)	int4(gds+88)
> #define GDS_SpectralLAM_polarStereo_Lo1(gds)	int4(gds+92)
> #define GDS_SpectralLAM_polarStereo_LaD(gds)	int4(gds+96)
> #define GDS_SpectralLAM_polarStereo_LoV(gds)	int4(gds+100)
> #define GDS_SpectralLAM_polarStereo_code_3_5(gds)	((int)(gds[104]))
> 
> #define GDS_SpectralLAM_lambert_La1(gds)	int4(gds+88)
> #define GDS_SpectralLAM_lambert_Lo1(gds)	int4(gds+92)
> #define GDS_SpectralLAM_lambert_LaD(gds)	int4(gds+96)
> #define GDS_SpectralLAM_lambert_LoV(gds)	int4(gds+100)
> #define GDS_SpectralLAM_lambert_code_3_5(gds)	((int)(gds[104])) 
> #define GDS_SpectralLAM_lambert_Latin1(gds)	int4(gds+105)
> #define GDS_SpectralLAM_lambert_Latin2(gds)	int4(gds+109)
> #define GDS_SpectralLAM_lambert_LatSP(gds)	int4(gds+113)
> #define GDS_SpectralLAM_lambert_LonSP(gds)	int4(gds+117)
> 
> 
diff -N wgrib2/Grib.c ../../wgrib2_mod/grib2/wgrib2/Grib.c
35a36
>     else if (strcmp(arg1,"bifourier") == 0) grib_type = bifourier;
146a148
>     else if (grib_type == bifourier) bifourier_grib_out (sec, data, ndata, use_scale, dec_scale, bin_scale, wanted_bits, max_bits, out);
405a408,409
> 
> 
diff -N wgrib2/Latlon.c ../../wgrib2_mod/grib2/wgrib2/Latlon.c
260c260
<     else if (grid_template == 10) {
---
>     else if ((grid_template == 10) || (grid_template == 13)) {
263c263
<     else if (grid_template == 20) {
---
>     else if ((grid_template == 20) || (grid_template == 23)) {
266c266
<     else if (grid_template == 30) {
---
>     else if ((grid_template == 30) || (grid_template == 33)) {
diff -N wgrib2/Sec3.c ../../wgrib2_mod/grib2/wgrib2/Sec3.c
83a84
>         case 13: /* mercator_lam */
85a87
>         case 23: /* polar_stereographic_lam */
86a89
>         case 33: /* lambert_lam */
128a132,137
>         case 61: /* Mercator bifourier */
>         case 62: /* Polar stereographic bifourier */
>         case 63: /* Lambert bifourier */
>             *nx = uint4_missing (gds+6);
>             *ny = 1;
>             break;
304a314
>     char lam_ext[128];
487,488c497,506
<             case 10: sprintf(inv_out,"%sMercator grid: (%s x %s) LatD %lf input %s output %s res %d%s",nl,
<                         nx_str(nx_), ny_str(ny_), GDS_Mercator_latD(gds), scan_order[scan>>4],output_order_name(),res,nl);
---
>             case 10: /* Mercator */
>             case 13: /* Mercator LAM */
> 		if (grid_template == 13)
>                   sprintf (lam_ext, " with LAM extension (U=[%d,%d],C=[%d,%d])", 
>                            GDS_Mercator_LAM_Nux(gds), GDS_Mercator_LAM_Nux(gds), 
> 			   GDS_Mercator_LAM_Ncx(gds), GDS_Mercator_LAM_Ncy(gds));
> 		else
>                   lam_ext[0] = 0;
> 		sprintf(inv_out,"%sMercator grid%s: (%s x %s) LatD %lf input %s output %s res %d%s", nl,
>                         lam_ext, nx_str(nx_), ny_str(ny_), GDS_Mercator_latD(gds), scan_order[scan>>4],output_order_name(),res,nl);
511,512c529,538
<             case 20: sprintf(inv_out,"%spolar stereographic grid: (%s x %s) input %s output %s res %d%s",nl,
<                         nx_str(nx_), ny_str(ny_), scan_order[scan>>4],output_order_name(), res,nl);
---
>             case 20: /* Polar stereographic */
>             case 23: /* Polar stereographic LAM */
> 		if (grid_template == 23)
>                   sprintf (lam_ext, " with LAM extension (U=[%d,%d],C=[%d,%d])", 
>                            GDS_Polar_LAM_Nux(gds), GDS_Polar_LAM_Nux(gds), 
> 			   GDS_Polar_LAM_Ncx(gds), GDS_Polar_LAM_Ncy(gds));
> 		else
>                   lam_ext[0] = 0;
> 		sprintf(inv_out,"%spolar stereographic grid%s: (%s x %s) input %s output %s res %d%s",nl,
>                         lam_ext, nx_str(nx_), ny_str(ny_), scan_order[scan>>4],output_order_name(), res,nl);
528,530c554,563
<             case 30:
<                 sprintf(inv_out,"%sLambert Conformal: (%s x %s) input %s output %s res %d%s",nl,
<                         nx_str(nx_), ny_str(ny_), scan_order[scan>>4],output_order_name(), res,nl);
---
>             case 30: /* Lambert conformal */
>             case 33: /* Lambert conformal LAM */
> 		if (grid_template == 33)
>                   sprintf (lam_ext, " with LAM extension (U=[%d,%d],C=[%d,%d])", 
>                            GDS_Lambert_LAM_Nux(gds), GDS_Lambert_LAM_Nux(gds), 
> 			   GDS_Lambert_LAM_Ncx(gds), GDS_Lambert_LAM_Ncy(gds));
> 		else
>                   lam_ext[0] = 0;
>                 sprintf(inv_out,"%sLambert Conformal%s: (%s x %s) input %s output %s res %d%s",nl,
>                         lam_ext, nx_str(nx_), ny_str(ny_), scan_order[scan>>4],output_order_name(), res,nl);
706a740,792
> 
> 	    case 61: sprintf(inv_out,"Spectral Mercator LaD %d N=%d M=%d, code_table_3.6=%d code_table_3.25=%d%s",
>                       GDS_SpectralLAM_mercator_LaD(gds),GDS_SpectralLAM_N(gds), GDS_SpectralLAM_M(gds), 
>                       GDS_SpectralLAM_code_3_6(gds), GDS_SpectralLAM_code_3_25(gds),nl);
>                   inv_out += strlen(inv_out);
> 		  sprintf(inv_out,"Subdomains definition lx=%ld lux=%ld lcx=%ld ly=%ld luy=%ld lcy=%ld%s",
>                       GDS_SpectralLAM_Lx(gds),GDS_SpectralLAM_Lux(gds),GDS_SpectralLAM_Lcx(gds)
> 		      ,GDS_SpectralLAM_Ly(gds),GDS_SpectralLAM_Luy(gds),GDS_SpectralLAM_Lcy(gds),nl);
>                   inv_out += strlen(inv_out);
> 		  sprintf(inv_out, "lat %d to %d %slon %d to %d %sorientation %lf",
>                         GDS_SpectralLAM_mercator_La1(gds), GDS_SpectralLAM_mercator_La2(gds), nl,
>                         GDS_SpectralLAM_mercator_Lo1(gds), GDS_SpectralLAM_mercator_Lo2(gds), nl, GDS_SpectralLAM_mercator_gridOrientation(gds));
>                   break;
> 	    
> 
> 	    case 62: sprintf(inv_out,"Spectral Polar Stereographic %d N=%d M=%d, code_table_3.6=%d code_table_3.25=%d%s",
>                       GDS_SpectralLAM_mercator_LaD(gds),GDS_SpectralLAM_N(gds), GDS_SpectralLAM_M(gds), 
>                       GDS_SpectralLAM_code_3_6(gds), GDS_SpectralLAM_code_3_25(gds),nl);
>                   inv_out += strlen(inv_out);
> 		  sprintf(inv_out,"Subdomains definition lx=%ld lux=%ld lcx=%ld ly=%ld luy=%ld lcy=%ld%s",
>                       GDS_SpectralLAM_Lx(gds),GDS_SpectralLAM_Lux(gds),GDS_SpectralLAM_Lcx(gds)
> 		      ,GDS_SpectralLAM_Ly(gds),GDS_SpectralLAM_Luy(gds),GDS_SpectralLAM_Lcy(gds),nl);
>                   inv_out += strlen(inv_out);
>                   sprintf(inv_out,"pole %d ", GDS_SpectralLAM_polarStereo_code_3_5(gds));
>                   inv_out += strlen(inv_out);
>                 
>                   sprintf(inv_out,"lat1 %d lon1 %d latD %d lonV %d",
>                     GDS_SpectralLAM_polarStereo_La1(gds), GDS_SpectralLAM_polarStereo_Lo1(gds),
>                     GDS_SpectralLAM_polarStereo_LaD(gds), GDS_SpectralLAM_polarStereo_LoV(gds));
>                   break;
> 	    
> 	    case 63: sprintf(inv_out,"Spectral Lambert %d N=%d M=%d, code_table_3.6=%d code_table_3.25=%d%s",
>                       GDS_SpectralLAM_mercator_LaD(gds),GDS_SpectralLAM_N(gds), GDS_SpectralLAM_M(gds), 
>                       GDS_SpectralLAM_code_3_6(gds), GDS_SpectralLAM_code_3_25(gds),nl);
>                   inv_out += strlen(inv_out);
> 		  sprintf(inv_out,"Subdomains definition lx=%ld lux=%ld lcx=%ld ly=%ld luy=%ld lcy=%ld%s",
>                       GDS_SpectralLAM_Lx(gds),GDS_SpectralLAM_Lux(gds),GDS_SpectralLAM_Lcx(gds)
> 		      ,GDS_SpectralLAM_Ly(gds),GDS_SpectralLAM_Luy(gds),GDS_SpectralLAM_Lcy(gds),nl);
>                   inv_out += strlen(inv_out);
>                   sprintf(inv_out,"%s ", GDS_SpectralLAM_lambert_code_3_5(gds) ? "North Pole": "South Pole");
>                   inv_out += strlen(inv_out);
>                 
>                   sprintf(inv_out,"lat1 %d lon1 %d latD %d lonV %d",
>                     GDS_SpectralLAM_lambert_La1(gds), GDS_SpectralLAM_lambert_Lo1(gds),
>                     GDS_SpectralLAM_lambert_LaD(gds), GDS_SpectralLAM_lambert_LoV(gds));
> 		  sprintf(inv_out, "latin1 %d latin2 %d latSP %d lonSP %d",
>                         GDS_SpectralLAM_lambert_Latin1(gds), GDS_SpectralLAM_lambert_Latin2(gds),
>                         GDS_SpectralLAM_lambert_LatSP(gds), GDS_SpectralLAM_lambert_LonSP(gds));
>                   break;
> 	    
> 
> 
> 
905c991
<             	      sprintf(inv_out,"no other grid info");
---
>             	      sprintf(inv_out,"no other grid info???");
1000c1086
<             default: sprintf(inv_out,"no other grid info");
---
>             default: sprintf(inv_out,"no other grid info!!");
1001a1088
> 
diff -N wgrib2/Sec5.c ../../wgrib2_mod/grib2/wgrib2/Sec5.c
117a118,130
> 	    else if (pack == 53) {
>                 sprintf(inv_out," val=(%lg+i*2^%d)*10^%d, i=0..%d (#bits=%d)", 
>                 ieee2flt(p+11), int2(p+15), -int2(p+17), (1 << p[19])-1, p[19]);
> 	        inv_out += strlen(inv_out);
> 		sprintf(inv_out," P-Laplacian scaling factor*10^-6=%d",int4(p+22));
> 	        inv_out += strlen(inv_out);
> 		sprintf(inv_out," Ns=%u Ms=%u", uint2(p+26), uint2(p+28));
> 	        inv_out += strlen(inv_out);
> 		sprintf(inv_out," SubTruncationType=%u doNotPackAxes=%u", p[20],p[21] );
> 	        inv_out += strlen(inv_out);
> 		sprintf(inv_out," code_table_5.7=%d", (int) p[30]);
> /*		sprintf(inv_out," mean?=%lg", ieee2flt(sec[7]+5)); */
> 	    }
diff -N wgrib2/unpk.c ../../wgrib2_mod/grib2/wgrib2/unpk.c
13a14
> #include "bifourier.h"
353a355,358
>     else if (packing == 53)
>     {
>       return unpack_bifourier (sec, data);
>     }
diff -N wgrib2/wgrib2.h ../../wgrib2_mod/grib2/wgrib2/wgrib2.h
91c91
< enum output_grib_type {jpeg,ieee_packing,simple,complex1,complex2,complex3,aec};
---
> enum output_grib_type {jpeg,ieee_packing,simple,complex1,complex2,complex3,aec,bifourier};
